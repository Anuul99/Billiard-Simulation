# -*- coding: utf-8 -*-
"""Billiard Simulation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wbokUpVVKWx1P9KSLCDBJz0icZF0EI-C
"""

import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# main classes
class Billiard():

    def __init__(self, id=0, r=np.zeros(2), v=np.zeros(2), R=5E-2, m=0.17, color="white"):
        self.id, self.r, self.v, self.R, self.m, self.color = id, r, v, R, m, color


class Simulation():
    
    length_x = 1.5  # m
    length_y = 3 # m
    
    def __init__(self, dt=1E-2, n=20):
        self.dt, self.n = dt, n
        self.ball = [Billiard(i) for i in range(self.n)]

    def movement(self):
        self.friction()
        self.collision() 
        for ball in self.ball:
            ball.r += ball.v * self.dt

    def position(self):
        return [ball.r for ball in self.ball]

    def color(self):
        return [ball.color for ball in self.ball]

    def velocity(self):
        return [np.sqrt((np.dot(ball.v, ball.v))) for ball in self.ball]

    def collision(self):
        ignore_list = []
        for ball_a in self.ball: 
            if ball_a in ignore_list:  # checking if the ball is outside of the boundary
                continue
            x, y = ball_a.r
            if ((x > self.length_x/2 - ball_a.R) or (x < -self.length_x/2+ball_a.R)): # if it is ouside of the boundary
                ball_a.v[0] *= -1  # multiplying by -1 to reflecte the ball velocity  
            if ((y > self.length_y/2 - ball_a.R) or (y < -self.length_y/2+ball_a.R)): 
                ball_a.v[1] *= -1

            for ball_b in self.ball: # checking where 2 balls are collided
                if id(ball_a) == id(ball_b):
                    continue
                m1, m2, r1, r2, v1, v2 = ball_a.m, ball_b.m, ball_a.r, ball_b.r, ball_a.v, ball_b.v
                if np.dot(r1-r2, r1-r2) <= (ball_a.R + ball_b.R)**2: # the magnitude squared is less than combined ball radii squared so that the balls have overlapped
                    v11 = v1 - 2*m2 / (m1+m2) * np.dot(v1-v2, r1-r2) / np.dot(r1-r2, r1-r2)*(r1-r2)
                    v22 = v2 - 2*m1 / (m1+m2) * np.dot(v2-v1, r2-r1) / np.dot(r2-r1, r2-r1)*(r2-r1)
                    ball_a.v = v11
                    ball_b.v = v22
                    ignore_list.append(ball_b)
    
    def friction(self):
        for ball_a in self.ball:
            if (np.sqrt(np.dot(ball_a.v, ball_a.v)) < 1E-6): # considering the speed of ball is 0 when it is low enough
                ball_a.v[0] = 0
                ball_a.v[1] = 0
            else:
                if (ball_a.v[0] > 0):
                    ball_a.v[0] -= u*g*self.dt
                else:
                    ball_a.v[0] += u*g*self.dt
             
                if (ball_a.v[1] > 0):
                    ball_a.v[1] -= u*g*self.dt
                else:
                    ball_a.v[1] += u*g*self.dt

# for animation purpose 
def init_func():
    ax.set_xlim(-sim.length_x/2, sim.length_x/2)
    ax.set_ylim(-sim.length_y/2, sim.length_y/2)
    ax.set(ylabel="Technically Billiard Table")
    ax2.set_xlim(vs[0], vs[-1])
    ax2.set_ylim(0, 2)
    ax2.set(xlabel="Velocity (m/s)", ylabel="Balls number")
    return (position_ball, *bar.patches)
# Updating each frame making it a video
def update(frame): 
    sim.movement() 
    freqs, bins = np.histogram(sim.velocity(), bins=vs)
    freqs_avg[frame % frm] = freqs
    freqs_mean = np.mean(freqs_avg, axis=0) 
    freqs_max = np.max(freqs_mean) # maximum value on bar chart in order to set up the y value as same as the ball numbers

    for rect, height in zip(bar.patches, freqs_mean): # getting the rectangle and height
        rect.set_height(height)

    if np.abs(freqs_max - ax2.get_ylim()[1]) > 10:
        ax2.set_ylim(0, 5 + ax2.get_ylim()[1] + (freqs_max - ax2.get_ylim()[1]))
        fig.canvas.draw()

    position_ball.set_offsets(np.array(sim.position())) # change the position
    position_ball.set_color(sim.color())
    return (position_ball, *bar.patches)

# variables
n = 16 # number of balls
m = 0.17 # kg
v = 10 # m/s
g = 9.81 # m/s^2
u = 0.3 # friction coefficient

sim = Simulation(n=n)
# giving a position to each ball
for ball in sim.ball:
    ball.m = m
    ball.r = np.random.uniform([-sim.length_x/2, -sim.length_y/2], [sim.length_x/2, sim.length_y/2], size=2) # we want uniformly distributed random number in the window
ball.v = v * np.array([np.cos(np.pi/4), np.cos(np.pi/4)]) # ball speed
#unit of distance which tells us the incremental change in distance with regards to its instantaneous speed
sim.ball[0].color = "cyan"
sim.ball[1].color = "red"
sim.ball[2].color = "yellow"
sim.ball[3].color = "blue"
sim.ball[4].color = "purple"
sim.ball[5].color = "orange"
sim.ball[6].color = "green"
sim.ball[7].color = "white"
sim.ball[8].color = "indigo"
sim.ball[9].color = "yellow"
sim.ball[10].color = "red"
sim.ball[11].color = "blue"
sim.ball[12].color = "purple"
sim.ball[13].color = "orange"
sim.ball[14].color = "green"
sim.ball[15].color = "cyan"

# Plotting the histogram
fig, (ax, ax2) = plt.subplots(figsize=(5, 8), nrows=2)
ax.set_xticks([]), ax.set_yticks([])
ax.set_aspect("equal")
plt.style.use('dark_background')  
plt.rcParams["font.size"] = 12
np.random.seed(0)

frm = 30 
vs = np.arange(0, 10, 0.1)
position_ball = ax.scatter([], [])
bar = ax2.bar(vs, [0]*len(vs), width=0.9 *np.gradient(vs), align="edge", alpha=0.8) # transparency
freqs_avg = np.tile((np.histogram(sim.velocity(), bins=vs)[0].astype(np.float)), (frm, 1))

anim = FuncAnimation(fig, update, frames=range(2000), init_func=init_func, blit=True, interval=1/30, repeat=False)
anim.save('turshilt1.mp4', dpi=150, fps=30, writer='ffmpeg')